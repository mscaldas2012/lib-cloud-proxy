<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>S3Proxy.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lib-cloud-proxy</a> &gt; <a href="index.source.html" class="el_package">gov.cdc.ncezid.cloud.storage.aws</a> &gt; <span class="el_source">S3Proxy.kt</span></div><h1>S3Proxy.kt</h1><pre class="source lang-java linenums">package gov.cdc.ncezid.cloud.storage.aws

import gov.cdc.ncezid.cloud.AWSConfig
import gov.cdc.ncezid.cloud.Providers
import gov.cdc.ncezid.cloud.storage.CloudFile
import gov.cdc.ncezid.cloud.storage.CloudStorage
import gov.cdc.ncezid.cloud.storage.META_CONTENT_ENCODING
import gov.cdc.ncezid.cloud.storage.META_CONTENT_LENGTH
import gov.cdc.ncezid.cloud.storage.META_CONTENT_TYPE
import gov.cdc.ncezid.cloud.util.decode
import gov.cdc.ncezid.cloud.util.validateFor
import gov.cdc.ncezid.cloud.util.withMetrics
import io.micrometer.core.instrument.MeterRegistry
import io.micronaut.context.annotation.Requires
import io.micronaut.http.MediaType
import org.slf4j.LoggerFactory
import software.amazon.awssdk.core.sync.RequestBody
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.s3.S3Client
import software.amazon.awssdk.services.s3.model.CompletedPart
import software.amazon.awssdk.services.s3.model.GetObjectRequest
import software.amazon.awssdk.services.s3.model.NoSuchKeyException
import software.amazon.awssdk.services.s3.model.ObjectIdentifier
import java.io.BufferedReader
import java.io.ByteArrayInputStream
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.time.Duration
import java.util.*
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import javax.inject.Singleton

private const val FILE_5MB = (5 * 1024 * 1024).toLong()
private const val VAR_BUCKET = &quot;s3.bucket&quot;

@Singleton
@Requires(property = &quot;aws.s3&quot;)
<span class="nc" id="L40">class S3Proxy(private val awsConfig: AWSConfig, private val meterRegistry: MeterRegistry? = null) : CloudStorage {</span>
<span class="nc" id="L41">    private val logger = LoggerFactory.getLogger(S3Proxy::class.java.name)</span>

<span class="nc" id="L43">    init {</span>
<span class="nc" id="L44">        logger.info(&quot;AUDIT- Initializing AWS S3Proxy with config: {}&quot;, awsConfig)</span>
<span class="nc" id="L45">    }</span>

<span class="nc" id="L47">    override fun provider(): Providers = Providers.AWS</span>

<span class="nc" id="L49">    private val s3Client = S3Client.builder().overrideConfiguration {</span>
<span class="nc" id="L50">        it.apiCallTimeout(Duration.ofSeconds(awsConfig.s3.apiCallTimeoutSeconds))</span>
<span class="nc" id="L51">            .apiCallAttemptTimeout(Duration.ofSeconds(awsConfig.s3.apiCallAttemptTimeoutSeconds))</span>
<span class="nc" id="L52">    }.region(Region.of(awsConfig.region)).build()</span>

<span class="nc" id="L54">    override fun getFile(fileName: String): CloudFile = awsConfig.s3.bucket.validateFor(VAR_BUCKET) {</span>
<span class="nc" id="L55">        getFile(it, fileName)</span>
<span class="nc" id="L56">    }</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">    override fun getDefaultBucket(): String = awsConfig.s3.bucket ?: &quot;N/A&quot;</span>

    @Throws
    override fun getFileContent(bucket: String, fileName: String): String =
<span class="nc" id="L62">        meterRegistry.withMetrics(&quot;s3.getFileContent&quot;) {</span>
<span class="nc" id="L63">            logger.debug(&quot;Getting fileContent for fileName: {} in bucket: {}&quot;, fileName, bucket)</span>
<span class="nc" id="L64">            runCatching {</span>
<span class="nc" id="L65">                try {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">                    s3Client.getObject { it.bucket(bucket).key(fileName) }.bufferedReader().use { it.readText() }</span>
<span class="nc" id="L67">                } catch (e: NoSuchKeyException) {</span>
<span class="nc" id="L68">                    getZipContent(bucket, fileName)</span>
                }
<span class="nc bnc" id="L70" title="All 2 branches missed.">            }.onFailure {</span>
<span class="nc" id="L71">                logger.error(</span>
<span class="nc" id="L72">                    &quot;Failed to get fileContent for fileName: {} in bucket: {}. Exception: {}&quot;,</span>
<span class="nc" id="L73">                    fileName,</span>
<span class="nc" id="L74">                    bucket,</span>
<span class="nc" id="L75">                    it</span>
                )
<span class="nc" id="L77">            }.getOrThrow()</span>
<span class="nc" id="L78">        }</span>

    // TODO - should throw exception if bucket doesn't exist (and same for others)
    override fun getFileContent(fileName: String): String =
<span class="nc" id="L82">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { getFileContent(it, fileName) }</span>

    override fun getFileContentAsInputStream(bucket: String, fileName: String): InputStream =
<span class="nc" id="L85">        meterRegistry.withMetrics(&quot;s3.getFileContentAsInputStream&quot;) {</span>
<span class="nc" id="L86">            logger.debug(&quot;Getting fileContent for fileName: {} in bucket: {}&quot;, fileName, bucket)</span>

<span class="nc" id="L88">            runCatching {</span>
<span class="nc" id="L89">                ByteArrayInputStream(s3Client.getObject { it.bucket(bucket).key(fileName) }.readAllBytes())</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            }.onFailure {</span>
<span class="nc" id="L91">                logger.error(</span>
<span class="nc" id="L92">                    &quot;Failed to get fileContent (as InputStream) for fileName: {} in bucket: {}. Exception: {}&quot;,</span>
<span class="nc" id="L93">                    fileName,</span>
<span class="nc" id="L94">                    bucket,</span>
<span class="nc" id="L95">                    it</span>
                )
<span class="nc" id="L97">            }.getOrThrow()</span>
<span class="nc" id="L98">        }</span>

    override fun getFileContentAsInputStream(fileName: String): InputStream =
<span class="nc" id="L101">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { getFileContentAsInputStream(it, fileName) }</span>

    @Throws
    override fun getMetadata(bucket: String, fileName: String, urlDecode: Boolean): Map&lt;String, String&gt; =
<span class="nc" id="L105">        meterRegistry.withMetrics(&quot;s3.getMetadata&quot;) {</span>
<span class="nc" id="L106">            logger.debug(&quot;Getting metaData for fileName: {} in bucket: {}&quot;, fileName, bucket)</span>

<span class="nc" id="L108">            runCatching {</span>
<span class="nc" id="L109">                s3Client.headObject { it.bucket(bucket).key(fileName) }.let {</span>
<span class="nc" id="L110">                    mapOf(&quot;last_modified&quot; to it.lastModified().toString())</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                        .plus(if (urlDecode) it.metadata().decode() else it.metadata())</span>
<span class="nc" id="L112">                        .plus(META_CONTENT_LENGTH to it.contentLength().toString())</span>
<span class="nc" id="L113">                        .plus(META_CONTENT_TYPE to it.contentType())</span>
<span class="nc" id="L114">                        .plus(META_CONTENT_ENCODING to it.contentEncoding())</span>
                }
<span class="nc bnc" id="L116" title="All 2 branches missed.">            }.onSuccess {</span>
<span class="nc" id="L117">                logger.debug(&quot;S3 File Metadata: {}&quot;, it)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            }.onFailure {</span>
<span class="nc" id="L119">                logger.error(</span>
<span class="nc" id="L120">                    &quot;Failed to get MetaData for fileName: {} in bucket: {}. Exception: {}&quot;, fileName, bucket, it</span>
                )
<span class="nc" id="L122">            }.getOrThrow()</span>
<span class="nc" id="L123">        }</span>


    override fun getMetadata(fileName: String, urlDecode: Boolean): Map&lt;String, String&gt; =
<span class="nc" id="L127">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { getMetadata(it, fileName, urlDecode) }</span>

    override fun saveFile(
        bucket: String,
        fileName: String,
        content: String,
        metadata: Map&lt;String, String&gt;?,
        contentType: String
<span class="nc" id="L135">    ): Unit = meterRegistry.withMetrics(&quot;s3.saveFile&quot;) {</span>
<span class="nc" id="L136">        logger.debug(</span>
<span class="nc" id="L137">            &quot;Saving File: {} to bucket: {}, with contentType: {} and MetaData: {} &quot;,</span>
<span class="nc" id="L138">            fileName, bucket, contentType, metadata</span>
        )

<span class="nc" id="L141">        runCatching {</span>
<span class="nc" id="L142">            s3Client.putObject({</span>
<span class="nc" id="L143">                it.key(fileName)</span>
<span class="nc" id="L144">                    .contentType(contentType)</span>
<span class="nc" id="L145">                    .bucket(bucket)</span>
<span class="nc" id="L146">                    .metadata(metadata)</span>
<span class="nc" id="L147">            }, RequestBody.fromString(content)).also {</span>
<span class="nc" id="L148">                logger.info(&quot;\tfile stored to S3 response: $it&quot;)</span>
<span class="nc" id="L149">            }</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        }.onFailure {</span>
<span class="nc" id="L151">            logger.error(&quot;Failed to Save File for fileName: {} in bucket: {}. Exception: {}&quot;, fileName, bucket, it)</span>
<span class="nc" id="L152">        }.getOrThrow()</span>
<span class="nc" id="L153">    }</span>

    override fun saveFile(
        bucket: String,
        fileName: String,
        content: InputStream,
        size: Long,
        metadata: Map&lt;String, String&gt;?,
        contentType: String
<span class="nc" id="L162">    ): Unit = meterRegistry.withMetrics(&quot;s3.saveFile.inputstream&quot;) {</span>
<span class="nc" id="L163">        runCatching {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if (size &gt; FILE_5MB)</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                uploadMultipartFile(bucket, content, fileName, size, metadata ?: mapOf())</span>
<span class="nc" id="L166">            else uploadSinglePart(bucket, fileName, content, size, contentType, metadata)</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        }.onFailure {</span>
<span class="nc" id="L168">            logger.error(</span>
<span class="nc" id="L169">                &quot;Failed to Save File (from InputStream) for fileName: {} in bucket: {}. Exception: {}&quot;,</span>
<span class="nc" id="L170">                fileName, bucket, it</span>
            )
<span class="nc" id="L172">        }.getOrThrow()</span>
<span class="nc" id="L173">    }</span>

    override fun saveFile(fileName: String, content: String, metadata: Map&lt;String, String&gt;?, contentType: String) =
<span class="nc" id="L176">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { saveFile(it, fileName, content, metadata, contentType) }</span>


    override fun saveFile(
        fileName: String,
        content: InputStream,
        size: Long,
        metadata: Map&lt;String, String&gt;?,
        contentType: String
    ): Unit =
<span class="nc" id="L186">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { saveFile(it, fileName, content, size, metadata, contentType) }</span>

    //Retrieves the first X number of files on a folder (if prefix is provided) or root if prefix is null:
    override fun list(bucket: String, maxNumber: Int, prefix: String?): List&lt;String&gt; =
<span class="nc" id="L190">        meterRegistry.withMetrics(&quot;s3.list&quot;) {</span>
<span class="nc" id="L191">            logger.debug(&quot;Listing max ({}) objects for bucket: {} with prefix {}&quot;, maxNumber, bucket, prefix)</span>

<span class="nc" id="L193">            runCatching {</span>
<span class="nc" id="L194">                s3Client.listObjects { l -&gt; l.bucket(bucket).maxKeys(maxNumber).prefix(prefix) }.let { res -&gt;</span>
<span class="nc" id="L195">                    logger.debug(&quot;Response has contents: {}&quot;, res.hasContents())</span>
<span class="nc" id="L196">                    res.contents().map { it.key() }</span>
                }
<span class="nc bnc" id="L198" title="All 2 branches missed.">            }.onFailure {</span>
<span class="nc" id="L199">                logger.error(&quot;Failed to List objects for bucket: {} with prefix {}. Exception: {}&quot;, bucket, prefix, it)</span>
<span class="nc" id="L200">            }.getOrThrow()</span>
<span class="nc" id="L201">        }</span>

    /**
     * This was introduced to be able to provide a 'silent' call to the aws s3 api
     */
<span class="nc" id="L206">    override fun healthCheck(): String = meterRegistry.withMetrics(&quot;s3.healthcheck&quot;) {</span>
<span class="nc" id="L207">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) {</span>
<span class="nc" id="L208">            s3Client.listObjects { req -&gt; req.bucket(it).maxKeys(1) }.responseMetadata().requestId()</span>
        }
<span class="nc" id="L210">    }</span>

    override fun list(maxNumber: Int, prefix: String?): List&lt;String&gt; =
<span class="nc" id="L213">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { list(it, maxNumber, prefix) }</span>

<span class="nc" id="L215">    override fun listFolders(bucket: String): List&lt;String&gt; = meterRegistry.withMetrics(&quot;s3.listFolders&quot;) {</span>
<span class="nc" id="L216">        runCatching {</span>
<span class="nc" id="L217">            with(list(bucket, 100)) {</span>
<span class="nc" id="L218">                logger.debug(&quot;List: {}&quot;, this)</span>
<span class="nc bnc" id="L219" title="All 6 branches missed.">                mapNotNull { it.takeIf { it.indexOf(&quot;/&quot;) &gt;= 0 } }</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                    .filter { it != &quot;&quot; }</span>
<span class="nc" id="L221">                    .distinctBy { it }</span>
            }
<span class="nc bnc" id="L223" title="All 2 branches missed.">        }.onFailure {</span>
<span class="nc" id="L224">            logger.error(&quot;Failed to List Folders for bucket: {}. Exception: {}&quot;, bucket, it)</span>
<span class="nc" id="L225">        }.getOrThrow()</span>
<span class="nc" id="L226">    }</span>

<span class="nc" id="L228">    override fun listFolders(): List&lt;String&gt; = awsConfig.s3.bucket.validateFor(VAR_BUCKET) { listFolders(it) }</span>

    override fun deleteFile(bucket: String, fileName: String): Int =
<span class="nc" id="L231">        meterRegistry.withMetrics(&quot;s3.deleteFile&quot;) {</span>
<span class="nc" id="L232">            runCatching {</span>
<span class="nc" id="L233">                val keyAsList = listOf(ObjectIdentifier.builder().key(fileName).build())</span>

<span class="nc" id="L235">                s3Client.deleteObjects { req -&gt;</span>
<span class="nc" id="L236">                    req.bucket(bucket).delete { it.objects(keyAsList) }</span>
<span class="nc" id="L237">                }.deleted().size</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            }.onFailure {</span>
<span class="nc" id="L239">                logger.error(&quot;Failed to Delete file: {} in bucket: {}. Exception: {}&quot;, fileName, bucket, it)</span>
<span class="nc" id="L240">            }.getOrThrow()</span>
<span class="nc" id="L241">        }</span>

    override fun deleteFile(fileName: String): Int =
<span class="nc" id="L244">        awsConfig.s3.bucket.validateFor(VAR_BUCKET) { deleteFile(it, fileName) }</span>

    private fun uploadSinglePart(
        bucket: String,
        fileName: String,
        content: InputStream,
        contentLength: Long,
<span class="nc" id="L251">        contentType: String = MediaType.TEXT_PLAIN,</span>
<span class="nc" id="L252">        metadata: Map&lt;String, String&gt;? = null</span>
    ) {
<span class="nc" id="L254">        logger.debug(</span>
<span class="nc" id="L255">            &quot;Uploading singlepart &quot; +</span>
<span class="nc" id="L256">            &quot;fileName: $fileName, &quot; +</span>
<span class="nc" id="L257">            &quot;bucket: $bucket, &quot; +</span>
<span class="nc" id="L258">            &quot;contentLength: $contentLength, &quot; +</span>
<span class="nc" id="L259">            &quot;contentType: $contentType&quot;</span>
        )

<span class="nc" id="L262">        s3Client.putObject({ pob -&gt;</span>
<span class="nc" id="L263">            pob.key(fileName)</span>
<span class="nc" id="L264">                .contentType(contentType)</span>
<span class="nc" id="L265">                .bucket(bucket)</span>
<span class="nc" id="L266">                .metadata(metadata)</span>
<span class="nc" id="L267">        }, RequestBody.fromInputStream(content, contentLength))</span>
<span class="nc" id="L268">    }</span>

    //Multipart uploads:
    private fun uploadMultipartFile(
        bucket: String,
        file: InputStream,
        filename: String,
        contentLength: Long,
        metadata: Map&lt;String, String&gt;
    ) {
<span class="nc" id="L278">        logger.debug(&quot;Processing multipart bucket: $bucket, key: $filename.&quot;)</span>
        //Create multipart upload request and response
<span class="nc" id="L280">        val uploadId: String = createMultipartUpload(filename, bucket, metadata)</span>
        //upload part by part
<span class="nc" id="L282">        val completedPartList = uploadMultiParts(file, contentLength, bucket, filename, uploadId)</span>
        // merge all parts uploaded
<span class="nc" id="L284">        completeMultiParts(completedPartList, bucket, filename, uploadId).also {</span>
<span class="nc" id="L285">            logger.debug(&quot;Uploaded Multipart file. Received eTag: {}&quot;, it)</span>
<span class="nc" id="L286">        }</span>
<span class="nc" id="L287">    }</span>

    private fun createMultipartUpload(key: String, bucket: String, metadata: Map&lt;String, String&gt;): String {
<span class="nc" id="L290">        logger.debug(&quot;Creating MultipartUpload with key: {}, bucket: {}, metaData: {}&quot;, key, bucket, metadata)</span>
<span class="nc" id="L291">        return s3Client.createMultipartUpload { mur -&gt; mur.key(key).bucket(bucket).metadata(metadata) }.uploadId()</span>
    }

    @Throws(IOException::class)
    private fun uploadMultiParts(
        file: InputStream,
        contentLength: Long,
        bucket: String,
        key: String,
        uploadId: String,
    ): List&lt;CompletedPart&gt; {
<span class="nc" id="L302">        var partSize = FILE_5MB // Set part size to 5 MB.</span>
<span class="nc" id="L303">        var filePosition: Long = 0</span>
<span class="nc" id="L304">        val completedPartList: MutableList&lt;CompletedPart&gt; = ArrayList()</span>
<span class="nc" id="L305">        var i = 1</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        while (filePosition &lt; contentLength) {</span>
            // last part could be less than 5 MB, adjust the part size as needed.
<span class="nc" id="L308">            partSize = partSize.coerceAtMost(contentLength - filePosition)</span>
            //s3Client.upload
<span class="nc" id="L310">            val eTag = s3Client.uploadPart({ upb -&gt;</span>
<span class="nc" id="L311">                upb.bucket(bucket).key(key).uploadId(uploadId).partNumber(i).contentLength(partSize)</span>
<span class="nc" id="L312">            }, RequestBody.fromInputStream(file, contentLength)).eTag()</span>

<span class="nc" id="L314">            logger.debug(&quot;part# $i , eTag: $eTag , fileposition: ${filePosition / (1024 * 1024)}MB, partsize: ${partSize / (1024 * 1024)}MB, contentLength: $contentLength.&quot;)</span>
<span class="nc" id="L315">            val completedPart = CompletedPart.builder().partNumber(i).eTag(eTag).build()</span>
<span class="nc" id="L316">            completedPartList.add(completedPart)</span>
<span class="nc" id="L317">            filePosition += partSize</span>
<span class="nc" id="L318">            i++</span>
        }
<span class="nc" id="L320">        return completedPartList</span>
    }

    private fun completeMultiParts(
        completedPartList: List&lt;CompletedPart&gt;,
        bucket: String,
        key: String,
        uploadId: String,
    ): String {
<span class="nc" id="L329">        logger.debug(&quot;Completing MultipartUpload with key: {}, bucket: {}, uploadId: {}&quot;, key, bucket, uploadId)</span>
<span class="nc" id="L330">        return s3Client.completeMultipartUpload { cmurb -&gt;</span>
<span class="nc" id="L331">            cmurb.bucket(bucket)</span>
<span class="nc" id="L332">                .key(key)</span>
<span class="nc" id="L333">                .uploadId(uploadId)</span>
<span class="nc" id="L334">                .multipartUpload { cmub -&gt; cmub.parts(completedPartList) }</span>
<span class="nc" id="L335">        }.eTag().replace(&quot;\&quot;&quot;.toRegex(), &quot;&quot;)</span>
    }

    private fun getZipContent(bucket: String, config: String): String {
<span class="nc" id="L339">        logger.debug(&quot;Getting Zip Content for bucket: {}&quot;, bucket)</span>
<span class="nc" id="L340">        val req = GetObjectRequest.builder().bucket(bucket).key(&quot;${config}.zip&quot;).build()</span>
<span class="nc" id="L341">        val res = s3Client.getObject(req)</span>
<span class="nc" id="L342">        val s3Content = res.readAllBytes()</span>

<span class="nc" id="L344">        val tempFile = File.createTempFile(UUID.randomUUID().toString(), &quot;.tmp&quot;)</span>
<span class="nc" id="L345">        tempFile.writeBytes(s3Content)</span>
<span class="nc" id="L346">        try {</span>
<span class="nc" id="L347">            ZipFile(tempFile).use { zf -&gt;</span>
<span class="nc" id="L348">                logger.debug(String.format(&quot;Inspecting contents of: %s\n&quot;, zf.name))</span>
<span class="nc" id="L349">                val zipEntries = zf.entries()</span>
<span class="nc" id="L350">                val iterator: Iterator&lt;*&gt; = zipEntries.asIterator() //.forEachRemaining(entry -&gt; {</span>
                //while (iterator.hasNext()) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">                val entry = iterator.next() as ZipEntry</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                return zf.getInputStream(entry).bufferedReader().use(BufferedReader::readText)</span>
                //}
            }
        } finally {
<span class="nc" id="L357">            tempFile.delete()</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>